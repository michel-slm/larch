#!/usr/bin/python
# Copyright 2010  Lars Wirzenius
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Excercise my btree implementation, for simple benchmarking purposes.
# The benchmark gets a location and an operation count as command line
# arguments.
#
# If the location is the empty string, an in-memory node store is used.
# Otherwise it must be a non-existent directory name.
#
# The benchmark will do the given number of insertions into the tree, and
# measure the speed of that. Then it will look up each of those, and measure
# the lookups.


import cProfile
import os
import random
import shutil
import sys
import time

import btree


def measure(keys, func, final):
    start = time.clock()
    for key in keys:
        func(key)
    final()
    end = time.clock()
    return end - start


def profile(keys, func, final, basename):
    def helper():
        for key in keys:
            func(key)
        final()
    globaldict = globals().copy()
    localdict = locals().copy()
    cProfile.runctx('helper()', globaldict, localdict, '%s.prof' % basename)


def main():
    if True:
        import logging
        logging.basicConfig(filename='btree.log', level=logging.DEBUG)

    location = sys.argv[1]
    n = int(sys.argv[2])
    do_profile = True if sys.argv[3] == 'yes' else False

    key_size = 19
    value_size = 128
    node_size = 64*1024

    codec = btree.NodeCodec(key_size)

    if location == '':
        ns = btree.NodeStoreMemory(node_size, codec)
    else:
        if os.path.exists(location):
            raise Exception('%s exists already' % location)
        os.mkdir(location)
        ns = btree.NodeStoreDisk(location, node_size, codec)

    forest = btree.Forest(ns)
    tree = forest.new_tree()
    
    # Create list of keys.
    keys = ['%0*d' % (key_size, i) for i in xrange(n)]
    
    # Calibrate.
    looptime = measure(keys, lambda key: None, lambda: None)

    # Measure inserts.
    random.shuffle(keys)
    value = 'x' * value_size
    if do_profile:
        profile(keys, lambda key: tree.insert(key, value), 
                lambda: forest.commit(), 'insert')
    else:
        insert_time = measure(keys, lambda key: tree.insert(key, value),
                              lambda: forest.commit())
        
    # Measure lookups.
    random.shuffle(keys)
    if do_profile:
        profile(keys, tree.lookup, lambda: None, 'lookup')
    else:
        lookup_time = measure(keys, lambda key: tree.lookup(key),
                              lambda: None) - looptime
        
    # Measure range lookups.
    random.shuffle(keys)
    max_key = max(keys)
    if do_profile:
        profile(keys, lambda key: tree.lookup_range(key, max_key), 
                lambda: None, 'lookup-range')
    else:
        lookup_range_time = measure(keys, 
                                    lambda key: tree.lookup_range(key, max_key),
                                    lambda: None) - looptime

    # Measure inserts into existing tree.
    random.shuffle(keys)
    if do_profile:
        profile(keys, lambda key: tree.insert(key, value), 
                lambda: forest.commit(), 'insert2')
    else:
        insert2_time = measure(keys, lambda key: tree.insert(key, value),
                               lambda: forest.commit())

    # Measure removes from tree.
    random.shuffle(keys)
    if do_profile:
        profile(keys, lambda key: tree.remove(key), 
                lambda: forest.commit(), 'remove')
    else:
        remove_time = measure(keys, lambda key: tree.remove(key),
                              lambda: forest.commit())

    # Report
    if do_profile:
        print 'View *.prof with ./viewprof for profiling results.'
    else:
        print 'num_operations: %d' % n
        print 'insert      : %5.3f s (%.1f/s)' % (insert_time, n/insert_time)
        print 'lookup      : %5.3f s (%.1f/s)' % (lookup_time, n/lookup_time)
        print 'lookup_range: %5.3f s (%.1f/s)' % (lookup_range_time, 
                                                 n/lookup_range_time)
        print 'insert2     : %5.3f s (%.1f/s)' % (insert2_time, n/insert2_time)
        print 'remove      : %5.3f s (%.1f/s)' % (remove_time, n/remove_time)

    # Clean up
    if location:
        shutil.rmtree(location)

if __name__ == '__main__':
    main()
